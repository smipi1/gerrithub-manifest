#!/bin/sh
# Copyright (C) 2015 Philips Lighting BV

# Includes
. /lib/functions/certs.sh

# Constants
SELF=`basename $0`
TMP_DIR=/tmp/${SELF}.$$
KERNEL_FILE=kernel.bin
ROOT_FILE=root.bin
FW2_CERTS_DIR=/home/swupdate/certs
PUB_PEM_UBOOT_VAR_PREFIX=fw2_cert_
IPBRIDGE_STOP_DELAY=3

# Internal variables
unset BOOTSLOT
unset NEXT_BOOTSLOT
unset NEXT_KERNEL_MTD
unset NEXT_ROOTFS_MTD
unset REGISTER_PUB_PEM_SIGN_CERT
unset DELETE_PUB_PEM_SIGN_CERT
unset UENV_RESTORE_PUB_PEM_SIGN_CERTS

# Options
unset FUNCTION
unset OTA_FILE_PATH
unset CMD_FIFO_PATH
unset PRINT_HELP
CONTAINER_OFFSET=0
CONTAINER_SIZE=0

ENC_KEY_FILE=/home/swupdate/certs/enc.k

help() {
	echo "
${SELF} [OPTIONS] FUNCTION

Hue bridge v2.0 software update daemon

Any one of the following FUNCTIONs can be specified:
	-h                    Prints this help
	-f OTA_FILE_PATH      Updates the software using the specified OTA file
	-l CMD_FIFO_PATH      Listen on the specified named pipe. Writes to the
	                      pipe should be a space-separated string specifying
	                      OTA_FILE_PATH CONTAINER_OFFSET CONTAINER_SIZE. If
	                      the specified PIPE_FILE_PATH doesn't exist, it will
	                      be automatically created.
	-c                    Lists registered PEM certificates for fw2 signature
	                      verification.
	-r PUB_PEM_SIGN_CERT  Registers a public PEM certificate for fw2 signature
	                      verification. Use '-' for standard input.
	-d PUB_PEM_SIGN_CERT  Deletes the public PEM certificate for fw2 signature
	                      verification
	-a                    Automatically restore fw2 signature certificates from
	                      U-Boot environment.

The following OPTIONS are available:
	-o CONTAINER_OFFSET  Specifies the container offset in the OTA file
	-s CONTAINER_SIZE    Specifies the container size in the OTA file
"
}

log() {
	echo "$*"
	logger -p daemon.notice -t ${SELF} "$*"
}

error() {
	echo "error: $*" >&2
	logger -p daemon.error -t ${SELF} "$*"
}

abort() {
	error "$*"
	exit 1
}

pipeToLog() {
	local LINE
	while read LINE; do
		log "${LINE}"
	done
}

abortAndPrintHelp() {
	error "$*"
	help >&2
	exit 1
}

nameToMtdDevice() {
	local PARTITION_NAME=$1
	awk '
		BEGIN {
			FS=":"
		}
		/^mtd[0-9]+:[ \t]+([0-9a-f]{8}[ \t]){2}"'${PARTITION_NAME}'"/ {
			print $1
		}
	' /proc/mtd
}

getUbootEnvVar() {
	fw_printenv -n $1
	return $?
}

syncWithSystemState() {
	BOOTSLOT="`getUbootEnvVar bootslot`"
	if [ -z "${BOOTSLOT}" ]; then
		abort "Cannot determine bootslot"
	elif [ "${BOOTSLOT}" -eq "0" ]; then
		NEXT_BOOTSLOT=1
	elif [ "${BOOTSLOT}" -eq "1" ]; then
		NEXT_BOOTSLOT=0
	else
		abort "Cannot detemine boot-slot"
	fi
	NEXT_KERNEL_MTD=`nameToMtdDevice kernel-${NEXT_BOOTSLOT}`
	NEXT_ROOTFS_MTD=`nameToMtdDevice root-${NEXT_BOOTSLOT}`
}

switchBootslot() {
	if ! sync; then
		error "Cannot sync file-system"
		return 1
	elif ! fw_setenv bootslot "${NEXT_BOOTSLOT}"; then
		error "Cannot change boot-slot"
		return 1
	else
		log "Rebooting: switched to boot-slot ${NEXT_BOOTSLOT}"
		return 0
	fi
}

isNandDevice() {
	local DEV_TYPE=`cat /sys/class/mtd/$1/type`
	if [ "${DEV_TYPE}" != "nor" ]; then
		return 0
	else
		return 1
	fi
}

eraseNand() {
	local DEVICE=$1
	log "Erasing ${DEVICE} (NAND)"
	if ! flash_eraseall -q /dev/${DEVICE} 2>&1; then
		return 1
	else
		return 0
	fi | pipeToLog
}

eraseNor() {
	local DEVICE=$1
	log "Erasing ${DEVICE} (NOR)"
	if ! mtd erase ${DEVICE} 2>&1; then
		return 1
	else
		return 0
	fi | pipeToLog
}

eraseMtd() {
	local DEVICE=$1
	if isNandDevice ${DEVICE}; then
		eraseNand ${DEVICE}
		return $?
	else
		eraseNor ${DEVICE}
		return $?
	fi
}

writeNand() {
	local DEVICE=$1
	log "Writing ${DEVICE} (NAND)"
	if ! nandwrite -p /dev/${DEVICE} - 2>&1; then
		return 1
	else
		return 0
	fi | pipeToLog
}

writeNor() {
	local DEVICE=$1
	log "Writing ${DEVICE} (NOR)"
	if ! mtd write - ${DEVICE} 2>&1; then
		return 1
	else
		return 0
	fi | pipeToLog
}

writeMtd() {
	local DEVICE=$1
	log "Writing unused boot-slot"
	if isNandDevice ${DEVICE}; then
		writeNand ${DEVICE}
		return $?
	else
		writeNor ${DEVICE}
		return $?
	fi
}

eraseNextMtds() {
	log "Erasing unused boot-slot"
	if ! eraseMtd ${NEXT_KERNEL_MTD}; then
		return 1
	elif ! eraseMtd ${NEXT_ROOTFS_MTD}; then
		return 1
	else
		return 0
	fi
}

extractContainer() {
	local OTA_FILE_PATH=$1;shift
	local CONTAINER_OFFSET=$1;shift
	local CONTAINER_SIZE=$1;shift
	local DD_ARGS=""
	if [ "${CONTAINER_SIZE}" -ne "0" ]; then
		DD_ARGS="count=${CONTAINER_SIZE} ${args}"
	fi
	if [ "${CONTAINER_OFFSET}" -ne "0" ]; then
		DD_ARGS="skip=${CONTAINER_OFFSET} ${args}"
	fi
	dd if=${OTA_FILE_PATH} bs=1 ${DD_ARGS}
	return $?
}

decryptContainer() {
	aes-256-cbc.sh -k ${ENC_KEY_FILE} -d
	return $?
}

extractRootAndKernelImages() {
	local OTA_FILE_PATH=$1;shift
	local CONTAINER_OFFSET=$1;shift
	local CONTAINER_SIZE=$1;shift
	local DEST_DIR=$1;shift
	if ! extractContainer ${OTA_FILE_PATH} ${CONTAINER_OFFSET} ${CONTAINER_SIZE}; then
		error "Cannot extract container"
		return 1
	fi | if ! decryptContainer; then
		error "Cannot decrypt container"
		return 1
	fi | if ! tar -C ${DEST_DIR} -xz ${ROOT_FILE} ${KERNEL_FILE} 2>/dev/null; then
		error "Cannot unpack container content"
		return 1
	else
		return 0
	fi
}

writeRootAndKernelImages() {
	local SRC_DIR=$1;shift
	local ROOT_PATH=${SRC_DIR}/${ROOT_FILE}
	local KERNEL_PATH=${SRC_DIR}/${KERNEL_FILE}
	if ! cat ${ROOT_PATH}; then
		error "Cannot read ${ROOT_PATH}"
		return 1
	fi | if ! writeMtd ${NEXT_ROOTFS_MTD}; then
		error "Cannot write root"
		return 1
	fi
	if ! cat ${KERNEL_PATH}; then
		error "Cannot read ${KERNEL_PATH}"
		return 1
	fi | if ! writeMtd ${NEXT_KERNEL_MTD}; then
		error "Cannot write kernel"
		return 1
	elce
		return 0
	fi
}

logHello() {
	log "hue Bridge Firmware Update"
	log "Boot-slot ${BOOTSLOT}: In-use by current software"
	log "Boot-slot ${NEXT_BOOTSLOT}: Free for updated software"
	log "Targeting ${NEXT_KERNEL_MTD}: Updated kernel software"
	log "Targeting ${NEXT_ROOTFS_MTD}: Updated root software"
}

updateFirmware() {
	local OTA_FILE_PATH=$1;shift
	local CONTAINER_OFFSET=$1;shift
	local CONTAINER_SIZE=$1;shift
	if [ -z "${OTA_FILE_PATH}" ]; then 
		error "Please specify a firmware image file"
		return 1
	elif ! [ -f "${OTA_FILE_PATH}" ]; then
		error "Specified image file doesn't point to a file"
		return 1
	elif ! mkdir ${TMP_DIR}; then
		error "Cannot create temporary directory: ${TMP_DIR}"
		return 1
	fi
	log "Extracting OTA file: ${OTA_FILE_PATH}"
	if ! extractRootAndKernelImages ${OTA_FILE_PATH} ${CONTAINER_OFFSET} ${CONTAINER_SIZE} ${TMP_DIR}; then
		error "${OTA_FILE_PATH} isn't a valid OTA image"
		return 1
	fi
	log "Erasing boot slot: ${NEXT_BOOTSLOT}"
	if ! eraseNextMtds; then
		error "Cannot erase free boot-slot"
		return 1
	fi
	log "Writing to boot slot: ${NEXT_BOOTSLOT}"
	if ! writeRootAndKernelImages ${TMP_DIR}; then
		error "Cannot write free boot-slot"
		return 1
	fi
	log "Switching boot slot: ${NEXT_BOOTSLOT}"
	if ! switchBootslot; then
		error "Cannot switch boot-slot"
		return 1
	else
		return 0
	fi
	return 1
}

stopIpBridgeAppAfter() {
	sleep $1
	log "Stopping ipbridge"
	/etc/init.d/ipbridge stop
}

startFirmwareUpdate() {
	local OTA_FILE_PATH
	local CONTAINER_OFFSET
	local CONTAINER_SIZE
	local CMD_FIFO_PATH=$1
	if ! [ -p ${CMD_FIFO_PATH} ]; then
		if ! mkfifo ${CMD_FIFO_PATH}; then
			error "Cannot create a named pipe at ${CMD_FIFO_PATH}"
			return 1
		fi
	fi
	log "Waiting for the OTA file path: ${CMD_FIFO_PATH}"
	while read OTA_FILE_PATH CONTAINER_OFFSET CONTAINER_SIZE <${CMD_FIFO_PATH}; do
		log "Processing OTA file: ${OTA_FILE_PATH}"
		if [ -z "${CONTAINER_OFFSET}" ]; then
			CONTAINER_OFFSET=0
		fi
		if [ -z "${CONTAINER_SIZE}" ]; then
			CONTAINER_SIZE=0
		fi
		stopIpBridgeAppAfter ${IPBRIDGE_STOP_DELAY} &
		if ! updateFirmware ${OTA_FILE_PATH} ${CONTAINER_OFFSET} ${CONTAINER_SIZE}; then
			error "Failed updating software"
		else
			log "Software updated"
		fi
		reboot
	done
}

uenvVariables() {
	if ! fw_printenv; then
		return 1
	fi | if ! awk -F '=' '/^[^#^ ]+=/{print $1}'; then
		return 1
	else
		return 0
	fi
}

uenvVariablesToCertNames() {
	awk '/^'${PUB_PEM_UBOOT_VAR_PREFIX}'/{gsub(/^'${PUB_PEM_UBOOT_VAR_PREFIX}'/,"");print}'
	return $?
}

listPubPemSignCertsInUbootEnv() {
	if ! uenvVariables; then
		abort "cannot read U-Boot environment"
	fi | if ! uenvVariablesToCertNames; then
		abort "cannot identify public PEM certificates in U-Boot environment"
	fi
}

listPubPemSignCertsInCertsDir() {
	local CERT
	for CERT in ${FW2_CERTS_DIR}/*.pem; do
		basename ${CERT}
	done
}

isInList() {
	local VALUE=$1;shift
	local LIST=$*
	local ITEM
	for ITEM in ${LIST}; do
		[ "${VALUE}" = "${ITEM}" ] && return 0
	done
	return 1
}

listPubPemSignCerts() {
	local UENV_CERTS=`listPubPemSignCertsInUbootEnv`
	[ "$?" -ne "0" ] && return 0
	local LOCAL_CERTS=`listPubPemSignCertsInCertsDir`
	[ "$?" -ne "0" ] && return 0
	local ALL_CERTS=`echo ${UENV_CERTS} ${LOCAL_CERTS} | xargs -n1 echo | sort -u`
	local CERT
	for CERT in ${ALL_CERTS}; do
		if ! isInList ${CERT} ${UENV_CERTS}; then
			echo "${CERT} (read-only)"
		elif ! isInList ${CERT} ${LOCAL_CERTS}; then
			echo "${CERT} (missing locally)"
		else
			echo "${CERT}"
		fi
	done
}

registerPubPemSignCert() {
	local FILENAME=$1
	local CERT_NAME
	local UENV_VAR_NAME
	local UENV_CERT_STRING
	if [ "${FILENAME}" == "-" ]; then
		CERT_NAME=default.pem
		FILENAME=/tmp/${SELF}.$$.pem
		cat >${FILENAME}
	else
		CERT_NAME=`basename ${FILENAME}`
	fi
	if ! [ -f "${FILENAME}" ]; then
		abortShowHelp "Not a valid file: ${FILENAME}"
	fi
	UENV_VAR_NAME=${PUB_PEM_UBOOT_VAR_PREFIX}${CERT_NAME}
	UENV_CERT_STRING=`cat ${FILENAME} | pemPublicKeyToPemString`
	if [ "$?" -ne "0" ]; then
		abort "Cannot register public PEM Certificate"
	elif [ -f ${FW2_CERTS_DIR}/${CERT_NAME} ]; then
		abort "cannot replace existing fw2 certificate: ${CERT_NAME}"
	elif ! cp ${FILENAME} ${FW2_CERTS_DIR}/${CERT_NAME}; then
		abort "Cannot to write to ${FW2_CERTS_DIR}"
	elif ! fw_setenv ${UENV_VAR_NAME} ''${UENV_CERT_STRING}''; then
		rm ${FW2_CERTS_DIR}/${CERT_NAME}
		abort "Cannot update U-Boot environment"
	else
		echo "registered `basename ${CERT_NAME}`"
		return 0
	fi
}

restorePubPemSignCertsFromUboot() {
	local RESULT=0
	local CERT_NAME
	local UENV_VAR_NAME
	local UENV_CERT_STRING
	local TMP_FILE=/tmp/${SELF}.$$.tmp
	local CERT_NAMES=`uenvVariables | uenvVariablesToCertNames`
	if [ "$?" -ne "0" ]; then
		abort "cannot identify fw2 PEM certificates in U-Boot environment"
	fi
	for CERT_NAME in ${CERT_NAMES}; do
		UENV_VAR_NAME=${PUB_PEM_UBOOT_VAR_PREFIX}${CERT_NAME}
		UENV_CERT_STRING=`fw_printenv -n ${UENV_VAR_NAME}`
		if [ "$?" -ne "0" ]; then
			error "cannot read U-Boot environment variable: ${UENV_VAR_NAME}"
			RESULT=1
			continue
		fi
		echo "${UENV_CERT_STRING}" | if ! pemStringToPemPublicKey; then
			error "not a valid public PEM certificate string: ${UENV_VAR_NAME}"
			RESULT=1
			continue
		fi >${TMP_FILE}
		if ! cp ${TMP_FILE} ${FW2_CERTS_DIR}/${CERT_NAME}; then
			error "cannot to write to ${FW2_CERTS_DIR}"
			RESULT=1
			continue
		fi
		echo "restored ${CERT_NAME}"
	done
	rm ${TMP_FILE}
	return ${RESULT}
}

deletePubPemSignCertFromUboot() {
	local CERT_NAME=$1
	local CERT_FILEPATH=${FW2_CERTS_DIR}/${CERT_NAME}
	local UENV_VAR_NAME=${PUB_PEM_UBOOT_VAR_PREFIX}${CERT_NAME}
	if ! fw_printenv -n ${UENV_VAR_NAME} 2>/dev/null 1>/dev/null; then
		abort "cannot remove read-only fw2 certificate: ${UENV_VAR_NAME}"
	elif ! [ -f "${CERT_FILEPATH}" ]; then
		abort "unknown public PEM certificate: ${CERT_NAME}"
	elif ! rm ${CERT_FILEPATH}; then
		abort "cannot remove ${CERT_FILEPATH}"
	elif ! fw_setenv ${UENV_VAR_NAME}; then
		abort "cannot update U-Boot environment"
	else
		echo "deleted ${CERT_NAME}"
		return 0
	fi
}

limitToSingleFunction() {
	local NEW_FUNCTION=$1
	if [ -n "${FUNCTION}" ]; then
		abort "functions cannot be combined: -${NEW_FUNCTION} and -${FUNCTION}"
	else
		FUNCTION=${NEW_FUNCTION}
	fi
}

# Parse the command-line arguments
while getopts ":hf:l:cr:d:ao:s:" OPT; do
	case "${OPT}" in
		h)
			limitToSingleFunction ${OPT}
			PRINT_HELP=1
			;;
		f)
			limitToSingleFunction ${OPT}
			OTA_FILE_PATH=${OPTARG}
			;;
		l)
			limitToSingleFunction ${OPT}
			CMD_FIFO_PATH=${OPTARG}
			;;
		c)
			limitToSingleFunction ${OPT}
			LIST_PUB_PEM_SIGN_CERTS=1
			;;
		r)
			limitToSingleFunction ${OPT}
			REGISTER_PUB_PEM_SIGN_CERT=${OPTARG}
			;;
		d)
			limitToSingleFunction ${OPT}
			DELETE_PUB_PEM_SIGN_CERT=${OPTARG}
			;;
		a)
			limitToSingleFunction ${OPT}
			UENV_RESTORE_PUB_PEM_SIGN_CERTS=1
			;;
		o)
			CONTAINER_OFFSET=${OPTARG}
			;;
		s)
			CONTAINER_SIZE=${OPTARG}
			;;
		:)
			abortAndPrintHelp "Option -${OPTARG} requires an argument"
			;;
		\?)
			abortAndPrintHelp "Option -${OPTARG} not supported"
			;;
	esac
done

if [ -z "${FUNCTION}" ]; then
	abortAndPrintHelp "FUNCTION not specified"
fi

if [ -n "${PRINT_HELP}" ]; then
	help
	exit 0
elif [ -n "${OTA_FILE_PATH}" ]; then
	syncWithSystemState
	logHello
	updateFirmware ${OTA_FILE_PATH} ${CONTAINER_OFFSET} ${CONTAINER_SIZE}
	exit $?
elif [ -n "${CMD_FIFO_PATH}" ]; then
	syncWithSystemState
	logHello
	startFirmwareUpdate ${CMD_FIFO_PATH}
	exit $?
elif [ -n "${LIST_PUB_PEM_SIGN_CERTS}" ]; then
	listPubPemSignCerts
	exit $?
elif [ -n "${REGISTER_PUB_PEM_SIGN_CERT}" ]; then
	registerPubPemSignCert ${REGISTER_PUB_PEM_SIGN_CERT}
	exit $?
elif [ -n "${UENV_RESTORE_PUB_PEM_SIGN_CERTS}" ]; then
	restorePubPemSignCertsFromUboot
	exit $?
elif [ -n "${DELETE_PUB_PEM_SIGN_CERT}" ]; then
	deletePubPemSignCertFromUboot ${DELETE_PUB_PEM_SIGN_CERT}
	exit $?
fi
